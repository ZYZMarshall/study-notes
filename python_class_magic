构造和初始化
每个人都知道一个最基本的魔术方法， __init__ 。通过此方法我们可以定义一个对象的初始操作。然而，当我调用 x = SomeClass() 的时候， 
__init__ 并不是第一个被调用的方法。实际上，还有一个叫做 __new__ 的方法，来构造这个实例。然后给在开始创建时候的初始化函数来传递参数。
在对象生命周期的另一端，也有一个 __del__ 方法。我们现在来近距离的看一看这三个方法:

__new__(cls, [...) __new__ 是在一个对象实例化的时候所调用的第一个方法。它的第一个参数是这个类，
其他的参数是用来直接传递给 __init__ 方法。 __new__ 方法相当不常用,但是它有自己的特性，
特别是当继承一个不可变的类型比如一个tuple或者string。我不希望在 __new__ 上有太多细节，因为并不是很有用处，但是在 Python文档 中有详细的阐述。

__init__(self, […) 此方法为类的初始化方法。当构造函数被调用的时候的任何参数都将会传给它。
(比如如果我们调用 x = SomeClass(10, 'foo'))，那么 __init__ 将会得到两个参数10和foo。 __init__ 在Python的类定义中被广泛用到。

__del__(self) 如果 __new__ 和 __init__ 是对象的构造器的话，那么 __del__ 就是析构器。它不实现语句 del x (以上代码将不会翻译为 x.__del__() )。它定义的是当一个对象进行垃圾回收时候的行为。当一个对象在删除的时需要更多的清洁工作的时候此方法会很有用，比如套接字对象或者是文件对象。注意，如果解释器退出的时候对象还存存在，就不能保证 __del__ 能够被执行，
所以 __del__ can’t serve as a replacement for good coding practices ()



用于比较的魔术方法
Python对实现对象的比较，使用魔术方法进行了大的逆转，使他们非常直观而不是笨拙的方法调用。
而且还提供了一种方法可以重写Python对对象比较的默认行为(通过引用)。以下是这些方法和他们的作用。

__cmp__(self, other) __cmp__ 是最基本的用于比较的魔术方法。它实际上实现了所有的比较符号(<,==,!=,etc.)，
但是它的表现并不会总是如你所愿(比如，当一个实例与另一个实例相等是通过一个规则来判断，而一个实例大于另外一个实例是通过另外一个规则来判断)。
如果 self < other 的话 __cmp__ 应该返回一个负数，当 self == other 的时候会返回0 ，
而当 self > other 的时候会返回正数。
通常最好的一种方式是去分别定义每一个比较符号而不是一次性将他们都定义。但是 __cmp__ 方法是你想要实现所有的比较符号而一个保持清楚明白的一个好的方法。

__eq__(self, other) 定义了等号的行为, == 。

__ne__(self, other) 定义了不等号的行为, != 。

__lt__(self, other) 定义了小于号的行为， < 。

__gt__(self, other) 定义了大于等于号的行为， >= 。


控制属性访问
许多从其他语言转到Python的人会抱怨它缺乏类的真正封装。(没有办法定义私有变量，然后定义公共的getter和setter)。
Python其实可以通过魔术方法来完成封装。我们来看一下:

__getattr__(self, name) 你可以定义当用户试图获取一个不存在的属性时的行为。
这适用于对普通拼写错误的获取和重定向，对获取一些不建议的属性时候给出警告(如果你愿意你也可以计算并且给出一个值)或者处理一个 AttributeError 。
只有当调用不存在的属性的时候会被返回。然而，这不是一个封装的解决方案。 
__setattr__(self, name, value) 与 __getattr__ 不同， __setattr__ 是一个封装的解决方案。
无论属性是否存在，它都允许你定义对对属性的赋值行为，以为这你可以对属性的值进行个性定制。
但是你必须对使用 __setattr__ 特别小心。之后我们会详细阐述。
__delattr__ 与 __setattr__ 相同，但是功能是删除一个属性而不是设置他们。
注意与 __setattr__ 相同，防止无限递归现象发生。(在实现 __delattr__ 的时候调用 del self.name 即会发生) __getattribute__(self, name) __getattribute__ 与它的同伴 __setattr__ 和 __delattr__ 配合非常好。
但是我不建议使用它。只有在新类型类定义中才能使用 __getattribute__ (在最新版本Python中所有的类都是新类型，在老版本中你可以通过继承 object 来制作一个新类。这样你可以定义一个属性值的访问规则。有时也会产生一些帝归现象。(这时候你可以调用基类的 __getattribute__ 方法来防止此现象的发生。)它可以消除对 __getattr__ 的使用，如果它被明确调用或者一个 AttributeError 被抛出，那么当实现 __getattribute__ 之后才能被调用。
此方法是否被使用其实最终取决于你的选择。)我不建议使用它因为它的使用几率较小(我们在取得一个值而不是设置一个值的时候有特殊的行为是非常罕见的。)而且它不能避免会出现bug。
